{
  "hash": "e12ed0300fe1c24e1bf90eb5d904ee2f",
  "result": {
    "markdown": "---\ntitle: \"Circumventing poor mixing in Bayesian model-based clustering\"\neditor: visual\ndata: 2022-08-01\ncategories: [Bayes]\nbibliography: cc.bib\n---\n\n\n## Summary\n\nPaper: [Consensus Clustering for Bayesian Mixture Models](https://bmcbioinformatics-biomedcentral-com.ezp.lib.cam.ac.uk/articles/10.1186/s12859-022-04830-8)\n\n-   Aim: Perform inference on Bayesian clustering methods when chains do not converge without reimplementation\n-   Pros: Easy to use and offers useful inference\n-   Cons: Inference is no longer Bayesian\n\n## Introduction\n\nThe first paper of my PhD was entitled \"[Consensus Clustering for Bayesian Mixture Models](https://bmcbioinformatics-biomedcentral-com.ezp.lib.cam.ac.uk/articles/10.1186/s12859-022-04830-8)\" and written with my supervisors Paul and Chris. I think that the paper is a little confused, but it covers some nice work. To overcome the issue of poor mixing that haunts Bayesian clustering, we proposed a heuristic method based on the consensus clustering algorithm of @Monti2003CC that appears to enable principled inference without reimplementing the sampler. However, the inference does lose the Bayesian interpretation.\n\nIf you have attempted to infer discrete latent structure using a Bayesian method implemented using Markov Chain Monte Carlo (*MCMC*) methods, then you've probably encountered the problem of poor mixing where chains become trapped in different clusterings and stop exploring the parameter space.There is a large body of literature about methods for navigating this problem in a principled fashion [see, e.g., @Dahl2003SplitMerge; @Jain2004SplitMerge; @Bouchard2017PGSM; @syed2021ScalablePT], but these state-of-the-art samplers tend to be time-consuming to implement. In this paper we proposed taking samples from many (relatively) short chains rather than a single long chain. This idea has seen a lot of mileage recently across a few different papers, but where we differ is we surrender our claim of being truly Bayesian. We have to do this as, while it is possibly that our samples are drawn from the target density, they are unlikely to be weighted correctly. However, we found that the expected values from the distributions sampled this way tended to be correct even if the variance might be too large.\n\n<!-- Markov Chain Monte Carlo (*MCMC*) methods are the most common tool for performing computational Bayesian inference in part thanks to their guaranteeing a full description of the target density in the limit of infinite draws. However, if the target density has multiple well-separated modes this property may not emerge in any finite number of samples. Instead the sampler might become stuck in a local region of high density for all draws for any feasible computational budget [see, e.g., the Supplementary Materials of @strauss2020gpseudoclust]. This problem is referred to as _poor mixing_ within the chain. There are methods that attempt to mitigate this problem. In Bayesian clustering introducing split-merge moves into the sampler, such as those proposed by [@Dahl2003SplitMerge, @Jain2004SplitMerge, @Bouchard2017PGSM], can improve exploration by proposing large changes in the current clustering. However, these suffer increased computational complexity as a result. Another approach, parallel tempering [@geyer1991markov, @OKABE2001435] is a non-reversible method that runs multiple chains that communicate with each other to consider state swaps when experiencing poor mixing. These methods have seen something of a resurgence recently [see, e.g., @syed2021ScalablePT, @syed2021pt] and appear to be a research area that could yield very powerful results, though I am not sure how implementation or tuning of these methods works in practice. However, Gibbs sampling remains the most common sampler implemented for Bayesian clustering methods, and reimplementation would be time consuming and not guaranteed to solve mixing problems in finite time. -->\n\n## Algorithm\n\nThe basic method is sketched below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nConsensus clustering for Bayesian methods\nInputs:\n  W: the number of chains to run\n  D: the number of iterations to run each chain for\n  sampler: the MCMC sampler for the method\n  priorDraw(): a method of drawing a sample from the prior distribution over the clustering space (this is often integrated into the sampler in practice)\n \nOutput:\n  c: a matrix of sampled partitions\n\nAlgorithm:\n  for(w in 1:W) {\n    # Differentiate the model runs using the random seed\n    set.seed(w);\n    c_0 <- prior();\n    for(r in 1:R) {\n      # Sample a new clustering based on the current partition\n      c_r <- sampler(c_r);\n    }\n    # Save the last iteration\n    c[w] <- c_r\n  }\n```\n:::\n\n\nObviously one can sample more quantities than just the clustering (as we do in the paper), but I think that clustering works particularly well with short chains. This is because we often care about co-clustering probabilities across sampled partitions rather than any single sample being correct; this means that if there is enough variety across a large number of poor (but better than random) sampled partitions we might still infer the correct structure. For other variables we need longer chains to have the correct expected value from our sampled distribution.\n\n# How to use consensus clustering in practice for Bayesian methods\n\nIn this post I want to show how to use consensus clustering. First, let's generate some data. I generate data with two overlapping clustering structures which emerge in different features (this aspect of the data is sometimes referred to as having two different views of the clustering). This ensures multi-modality is present. The data has 200 samples, 15 variables informing each clustering and 40 noise variables. The first clustering has 4 clusters, the second 9 that are (approximately) nested in the first less fine clustering.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# For ggplot2 theme and data simulation\nlibrary(mdiHelpR)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'mdiHelpR'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:methods':\n\n    show\n```\n:::\n\n```{.r .cell-code}\n# For mixture models\nlibrary(MDIr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'MDIr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:mdiHelpR':\n\n    createSimilarityMat, findOrder, generateGaussianDataset,\n    generateSimulationDataset\n```\n:::\n\n```{.r .cell-code}\nlibrary(magrittr)\nlibrary(patchwork)\nlibrary(tidyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'tidyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:magrittr':\n\n    extract\n```\n:::\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\nset.seed(1)\nsetMyTheme()\n\nN <- 200\nP <- c(15, 15)\nP_n <- 20\ndelta_mu <- c(0.8, 1.1)\nK <- c(9, 4)\npi <- list()\npi[[1]] <- rep(1 / K[1], K[1])\npi[[2]] <- c(2, 4, 4, 1)\npi[[2]] <- pi[[2]] / sum(pi[[2]])\n\nn_views <- 2\n\nmy_df <- my_data <- NULL\ngroup_IDs <- matrix(0, nrow = N, ncol = n_views)\n\nfor (ii in seq(1, n_views)) {\n  .x <- generateSimulationDataset(K[ii],\n    N,\n    P[ii],\n    delta_mu = delta_mu[ii],\n    pi = pi[[ii]],\n    p_n = P_n\n  )\n\n  .data <- scale(.x$data)\n  group_IDs[, ii] <- .x$cluster_IDs\n\n  .df <- .data |>\n    as.data.frame()\n  .df[[paste0(\"Group\", ii)]] <- .x$cluster_IDs\n\n  if (ii == 1) {\n    my_df <- .df\n    my_data <- .data\n  } else {\n    my_df <- cbind(my_df, .df)\n    my_data <- cbind(my_data, .data)\n  }\n}\n\n# annotatedHeatmap(my_data, group_IDs[, 1])\n# annotatedHeatmap(my_data, group_IDs[, 2])\n\n# Create the annotation data.frame for the rows\nanno_row <- data.frame(\n  \"View_1\" = factor(paste(\"Cluster\", group_IDs[, 1])),\n  \"View_2\" = factor(paste(\"Cluster\", group_IDs[, 2]))\n) |>\n  magrittr::set_rownames(rownames(my_data))\n\nann_colours <- list(\n  \"View_1\" = c(ggthemes::colorblind_pal()(8), viridis::viridis(1)),\n  \"View_2\" = ggthemes::colorblind_pal()(4)\n)\n\nnames(ann_colours$View_1) <- paste(\"Cluster\", seq(1, K[1]))\nnames(ann_colours$View_2) <- paste(\"Cluster\", seq(1, K[2]))\n\n# Create the heatmap\nph <- pheatmap::pheatmap(my_data,\n  color = dataColPal(),\n  breaks = defineDataBreaks(my_data, dataColPal(), 0),\n  annotation_row = anno_row,\n  annotation_colors = ann_colours,\n  main = \"Generated data annotated by clusterings\",\n  show_colnames = FALSE,\n  show_rownames = FALSE\n)\n\nph\n```\n\n::: {.cell-output-display}\n![](consensus_clustering_files/figure-html/dataGen-1.png){width=672}\n:::\n:::\n\n\n## Guessing chain length\n\nTo use consensus clustering, we want to have an idea of how long we will need to run the chains for. In this case we run a small number of chains for longer than necessary and the look at trace plots to see when they stopped exploring or the degree of exploration had tapered off significantly.\n\n\n::: {.cell hash='consensus_clustering_cache/html/initial_runs_bf4eb09f33909e1cb33a9cf8687ca79c'}\n\n```{.r .cell-code}\nn_initial_chains <- 9\nR_long <- 5000\nthin_long <- 50\niterations_initial <- seq(0, R_long, thin_long)\n\nn_samples <- floor(R_long / thin_long) + 1\ntype <- \"G\"\n\npsms <- initial_mcmc <- vector(\"list\", n_initial_chains)\nlikelihood_df <- matrix(0, nrow = n_samples - 1, ncol = n_initial_chains)\ncolnames(likelihood_df) <- paste0(\"Chain\", seq(1, n_initial_chains))\n\nari_mat <- concentration_df <- matrix(0, nrow = n_samples, ncol = n_initial_chains)\ncolnames(ari_mat) <- colnames(concentration_df) <- paste0(\"Chain\", seq(1, n_initial_chains))\n\nensemble_psm <- matrix(0, nrow = N, ncol = N)\n\nfor (ii in seq(1, n_initial_chains)) {\n  initial_mcmc[[ii]] <- .mcmc <- callMixtureModel(my_data, R_long, thin_long, type)\n  likelihood_df[, ii] <- .mcmc$complete_likelihood[-1]\n  concentration_df[, ii] <- .mcmc$mass\n  ari_mat[, ii] <- apply(.mcmc$allocations, 1, function(x) {mcclust::arandi(x, .mcmc$allocations[n_samples, ])})\n  .psm <- makePSM(initial_mcmc[[ii]]$allocations)\n  row.names(.psm) <- colnames(.psm) <- row.names(my_data)\n  psms[[ii]] <- .psm\n  ensemble_psm <- ensemble_psm + .psm\n}\n\nensemble_psm <- ensemble_psm / n_initial_chains\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nari_df <- ari_mat |> \n  as.data.frame() |> \n  mutate(Iteration = iterations_initial) |>\n  pivot_longer(-Iteration, names_to = \"Chain\", values_to = \"ARI\")\n\nlikelihood_df2 <- likelihood_df |>\n  as.data.frame() |>\n  mutate(Iteration = iterations_initial[-1]) |>\n  pivot_longer(-Iteration, names_to = \"Chain\", values_to = \"Complete_log_likelihood\")\n\nmass_df <- concentration_df |>\n  as.data.frame() |>\n  mutate(Iteration = iterations_initial) |>\n  pivot_longer(-Iteration, names_to = \"Chain\", values_to = \"Mass\")\n\nlikelihood_df2 |>\n  ggplot(aes(x = Iteration, y = Complete_log_likelihood, group = Chain)) +\n  geom_line() +\n  ggthemes::scale_color_colorblind()\n```\n\n::: {.cell-output-display}\n![](consensus_clustering_files/figure-html/check_behaviour_initial_chains-1.png){width=672}\n:::\n\n```{.r .cell-code}\nmass_df |>\n  ggplot(aes(x = Iteration, y = Mass, group = Chain)) +\n  geom_line() +\n  ggthemes::scale_color_colorblind()\n```\n\n::: {.cell-output-display}\n![](consensus_clustering_files/figure-html/check_behaviour_initial_chains-2.png){width=672}\n:::\n\n```{.r .cell-code}\nari_df |> \n  ggplot(aes(x = Iteration, y = ARI, group = Chain)) +\n  geom_line() +\n  ggthemes::scale_color_colorblind() +\n  labs(title = \"ARI between rth sampled partition and final sampled partition in each chains\")\n```\n\n::: {.cell-output-display}\n![](consensus_clustering_files/figure-html/check_behaviour_initial_chains-3.png){width=672}\n:::\n\n```{.r .cell-code}\npsm <- makePSM(.mcmc$allocations)\nrow.names(psm) <- colnames(psm) <- row.names(my_data)\n\n# Create the heatmap of the PSM\npheatmap::pheatmap(psm,\n  color = simColPal(),\n  breaks = defineBreaks(simColPal(), lb = 0),\n  annotation_row = anno_row,\n  annotation_colors = ann_colours,\n  main = \"Example PSM annotated by clusterings\",\n  show_rownames = FALSE,\n  show_colnames = FALSE\n)\n```\n\n::: {.cell-output-display}\n![](consensus_clustering_files/figure-html/check_behaviour_initial_chains-4.png){width=672}\n:::\n\n```{.r .cell-code}\npsm_df <- prepSimilarityMatricesForGGplot(psms)\n\npsm_df |>\n  ggplot(aes(x = x, y = y, fill = Entry)) +\n  geom_tile() +\n  facet_wrap(~Chain) +\n  scale_fill_gradient(\n    low = \"#FFFFFF\",\n    high = \"#146EB4\"\n  ) +\n  labs(title = \"PSMs for initial chains with common ordering\")\n```\n\n::: {.cell-output-display}\n![](consensus_clustering_files/figure-html/check_behaviour_initial_chains-5.png){width=672}\n:::\n:::\n\n\nThese long chains have stopped exploring new clusterings almost instantly. The mass parameter takes awhile to converge, but this is sampled via Metropolis-Hastings, so this makes sense.\n\nThese PSMs also show why nested $\\hat{R}$ and coupling don't work for clustering. These methods assume that the different chains can eventually reach similar places; this is unlikely to happen in any reasonable length of time in even as low-dimensional an example as this (70 features; hardly low-dimensional in many settings, but that's one of the joys of 'omics).\n\n# Consensus clustering\n\nNow having an idea that the chains have found whatever structure they are going to find by the 100th iteration, we run an ensemble of chains for an excessive 1,000 iterations.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nD_considered <- c(100, 300, 600, 1000)\nD <- max(D_considered)\nnumber_depths <- length(D_considered)\n\nW_considered <- c(50, 100, 250, 500)\nW <- max(W_considered)\nnumber_chains <- length(W_considered)\n\nmodels <- expand.grid(D_considered, W_considered)\ncolnames(models) <- c(\"Depth\", \"Width\")\nn_models <- nrow(models)\n\nthin <- 100\niterations <- seq(0, D, thin)\n\nallocation_list <- consensus_chains <- vector(\"list\", W)\n\nconsensus_matrix <- matrix(0, nrow = N, ncol = N)\n\nconsensus_matrices <- vector(\"list\", n_models)\n\nallocations <- vector(\"list\", length(D_considered))\n\n# account for saving of 0th iterations\nsamples_extracted <- (D_considered / thin) + 1\n```\n:::\n\n::: {.cell hash='consensus_clustering_cache/html/consensusModelling_75aa9488f7c28d07298aee90e7e25bc4'}\n\n```{.r .cell-code}\nfor (ii in seq(1, W)) {\n  .mcmc <- callMixtureModel(my_data, D, thin, type)\n\n  for (jj in seq(1, number_depths)) {\n    curr_d <- D_considered[jj]\n    sample_used <- samples_extracted[jj]\n\n    .alloc <- .mcmc$allocations[sample_used, ]\n    .ll <- .mcmc$complete_likelihood[sample_used]\n    .mass <- .mcmc$mass[sample_used]\n\n    .lkl_entry <- data.frame(\n      \"Complete_log_likelihood\" = .ll,\n      \"D\" = curr_d,\n      \"Chain\" = ii\n    )\n\n    .mass_entry <- data.frame(\n      \"Mass\" = .mass,\n      \"D\" = curr_d,\n      \"Chain\" = ii\n    )\n\n    if (ii == 1) {\n      allocations[[jj]] <- .alloc\n      lkl_df <- .lkl_entry\n      mass_df <- .mass_entry\n    } else {\n      allocations[[jj]] <- rbind(allocations[[jj]], .alloc)\n      lkl_df <- rbind(lkl_df, .lkl_entry)\n      mass_df <- rbind(mass_df, .mass_entry)\n    }\n  }\n}\n\ncms <- vector(\"list\", n_models)\n\nfor (ii in seq(1, number_chains)) {\n  curr_w <- W_considered[ii]\n  chains_used <- seq(1, curr_w)\n\n  for (jj in seq(1, number_depths)) {\n    curr_cm_index <- (ii - 1) * number_depths + jj\n\n    curr_d <- D_considered[jj]\n    .cm <- makePSM(allocations[[jj]][chains_used, ])\n    row.names(.cm) <- colnames(.cm) <- row.names(my_data)\n    cms[[curr_cm_index]] <- .cm\n  }\n}\n\ncc_lst <- list(\n  \"CMs\" = cms,\n  \"likelihood_df\" = lkl_df,\n  \"mass_df\" = mass_df,\n  \"allocations\" = allocations\n)\n```\n:::\n\n\nWe use the CM from the largest number of chains and deepest sample for some visualisation, annotating by the two different generating clusterings.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npheatmap::pheatmap(cms[[9]],\n  color = simColPal(),\n  breaks = defineBreaks(simColPal(), lb = 0),\n  annotation_row = anno_row,\n  annotation_colors = ann_colours,\n  main = \"CM annotated by clusterings\",\n  show_colnames = FALSE,\n  show_rownames = FALSE\n)\n```\n\n::: {.cell-output-display}\n![](consensus_clustering_files/figure-html/mk2-1.png){width=672}\n:::\n:::\n\n\nThen we consider the trace plots for different samples and numbers of chains.\n\n\n::: {.cell}\n\n```{.r .cell-code}\np_lkl_100 <- lkl_df |>\n  filter(Chain < W_considered[1]) |>\n  ggplot(aes(x = Complete_log_likelihood, group = D)) +\n  geom_density(aes(fill = factor(D)), alpha = 0.4) +\n  ggthemes::scale_fill_colorblind() +\n  labs(fill = \"Chain depth\", subtitle = \"Complete log-likelihood for 100th sample from each chain\")\n\np_lkl_all <- lkl_df |>\n  ggplot(aes(x = Complete_log_likelihood, group = D)) +\n  geom_density(aes(fill = factor(D)), alpha = 0.4) +\n  ggthemes::scale_fill_colorblind() +\n  labs(fill = \"Chain depth\", subtitle = \"Complete log-likelihood for 1,000th sample from each chain\")\n\np_mass_100 <- mass_df |>\n  filter(Chain < W_considered[1]) |>\n  ggplot(aes(x = Mass, group = D)) +\n  geom_density(aes(fill = factor(D)), alpha = 0.4) +\n  ggthemes::scale_fill_colorblind() +\n  labs(fill = \"Chain depth\", subtitle = \"Mass density for 100th sample from each chain\")\n\np_mass_all <- mass_df |>\n  ggplot(aes(x = Mass, group = D)) +\n  geom_density(aes(fill = factor(D)), alpha = 0.4) +\n  ggthemes::scale_fill_colorblind() +\n  labs(fill = \"Chain depth\", subtitle = \"Mass density for 1,000th sample from each chain\")\n\np_lkl_100 / p_lkl_all + plot_annotation(\n  title = \"Complete log-likelihood for full ensemble and subset of chains\",\n) + plot_layout(guides = \"collect\")\n```\n\n::: {.cell-output-display}\n![](consensus_clustering_files/figure-html/trace_plots-1.png){width=672}\n:::\n\n```{.r .cell-code}\np_mass_100 / p_mass_all + plot_annotation(\n  title = \"Mass parameter for full ensemble and subset of chains\"\n) + plot_layout(guides = \"collect\")\n```\n\n::: {.cell-output-display}\n![](consensus_clustering_files/figure-html/trace_plots-2.png){width=672}\n:::\n:::\n\n\nThe complete log-likelihoods appear to be stable from the 100th iteration, and sampled mass densities appear to have stabilised by the 500th iteration being slower as it is sampled via Metropolis-Hastings.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncm_df <- prepSimilarityMatricesForGGplot(cms)\n\ncm_df$W <- 1\ncm_df$D <- 1\n\nfor (ii in seq(1, number_chains)) {\n  curr_w <- W_considered[ii]\n  # chains_used <- seq(1, curr_w)\n\n  for (jj in seq(1, number_depths)) {\n    curr_cm_index <- (ii - 1) * number_depths + jj\n    rel_entries <- which(cm_df$Chain == curr_cm_index)\n\n    curr_d <- D_considered[jj]\n    cm_df$W[rel_entries] <- curr_w\n    cm_df$D[rel_entries] <- curr_d\n  }\n}\n\n\ncm_df |>\n  mutate(Sample_used = D, Number_chains = W) |>\n  ggplot(aes(x = x, y = y, fill = Entry)) +\n  geom_tile() +\n  facet_grid(Sample_used ~ Number_chains, labeller = label_both) +\n  scale_fill_gradient(\n    low = \"#FFFFFF\",\n    high = \"#146EB4\"\n  )\n```\n\n::: {.cell-output-display}\n![](consensus_clustering_files/figure-html/cm_plots-1.png){width=672}\n:::\n:::\n\n\nThe consensus matrices appear very stable from the smallest and shallowest ensemble, in keeping with the impression from the complete log-likelihoods.\n\n# Testing\n\nTesting for convergence in Bayesian inference is difficult. Tests/diagnostics can be split in two categories, within chain and across chain. Within chain stationarity is normally assessed heuristically via trace plots and using the Geweke tests (essentially a t-test between samples at different stages of the chain). For across chains, $\\hat{R}$ dominates. Both of these have shortcomings; for example if a chain explore many modes in the posterior, the Geweke test and trace plots will suggest discarding it despite this being desirable behaviour in many settings (being a more depiction of the model uncertainty). Furthermore, when using the Geweke test we want to accept the null hypothesis which is just plain odd. As for $\\hat{R}$, the authors make no claims on how strong a guarantee small values are and this has been the source of much discussion in recent literature with many improvements recommended [see @Vats2021Revisiting; @Vehtari2021RankNormalisation; @Moins2022LocalRhat]. <!-- Vats and Knudson, 2021](https://projecteuclid-org.ezp.lib.cam.ac.uk/journals/statistical-science/volume-36/issue-4/Revisiting-the-GelmanRubin-Diagnostic/10.1214/20-STS812.full); [Vehtari et al., 2021](https://projecteuclid-org.ezp.lib.cam.ac.uk/journals/bayesian-analysis/volume-16/issue-2/Rank-Normalization-Folding-and-Localization--An-Improved-R%cb%86-for/10.1214/20-BA1221.full); [Moins et al., 2022](https://arxiv.org/abs/2205.06694)). --> However, most practitioners still use the original form and the threshold of 1.1.\n\nWith this context I would like to argue that the inference from our proposed method can provide a better approximationof the target densitty than the approach of a single long chain. Our method is more likely to draw samples from the entire support of the posterior, but I suspect it is giving the wrong posterior density to the modes drawn which is the reason I would consider this inference non-Bayesian. However, the logic of convergence can still be applied in considering if we have used a sufficient quantity of chains and if they are of sufficient length. To do this, we would like to assess if the distribution of sampled parameters is not changing for increasing chain length and increasing numbers of chains. My belief is that if the behaviour has stabilised then the chains have reached their stationary distribution and the sample size across chains is sufficiently large to describe the posterior well. We have some disadvantages in that samples across chains are not ordered; however the origin of this property also means that we do not have to worry about auto-correlation across chains and therefore are more robust to multi-modal densities (the big reason to like this approach in my view). Below are two sections, `depth tests` and `width tests` that outline my approach to assessing these behaviours. Note that we must tests depth and width separately, much as we test within and across chain convergence separately.\n\nNote that I use t-tests, but we could use something that is more targeted to compare the sampled distributions rather than some summary statistic of them.\n\n## Depth tests\n\nEssentially we will follow the logic of Geweke and compare the distribution using early samples to later samples. We differ in that the two sets of samples are collected across many chains, but I think the logic holds. Here we use a t test to test if the sampled distributions of the mass parameter for the clustering and the complete log-likelihood are the same in earlier samples to the same distributions for the final sample from all the chains.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm1 <- mass_df$Mass[mass_df$D == 100]\nm2 <- mass_df$Mass[mass_df$D == 300]\nm3 <- mass_df$Mass[mass_df$D == 600]\nm4 <- mass_df$Mass[mass_df$D == 1000]\n\nl1 <- lkl_df$Complete_log_likelihood[lkl_df$D == 100]\nl2 <- lkl_df$Complete_log_likelihood[lkl_df$D == 300]\nl3 <- lkl_df$Complete_log_likelihood[lkl_df$D == 600]\nl4 <- lkl_df$Complete_log_likelihood[lkl_df$D == 1000]\n\nt_d1_m_1 <- t.test(m1, m4)\nt_d1_m_2 <- t.test(m2, m4)\nt_d1_m_3 <- t.test(m3, m4)\n\nt_d1_l_1 <- t.test(l1, l4)\nt_d1_l_2 <- t.test(l2, l4)\nt_d1_l_3 <- t.test(l3, l4)\n```\n:::\n\n\n## Width tests\n\nTesting if we are using a sufficient quantity of chains is harder as the chains are not ordered. I believe we can essentially copy the Geweke test again but compare disjoint subsets of samples. For example, take the final sample from a random two fifths of the chains and compare the distribution for these to the distribution from the remaining three fifths and then repeat this multiple times.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfrac_used <- 0.4\ninds1 <- sample(seq(1, W), size = W * frac_used, replace = FALSE)\ninds2 <- sample(seq(1, W), size = W * frac_used, replace = FALSE)\ninds3 <- sample(seq(1, W), size = W * frac_used, replace = FALSE)\ninds4 <- sample(seq(1, W), size = W * frac_used, replace = FALSE)\ninds5 <- sample(seq(1, W), size = W * frac_used, replace = FALSE)\n\nt_w1_m <- t.test(m3[inds1], m3[-inds1])\nt_w1_l <- t.test(l3[inds1], l3[-inds1])\n\nt_w2_m <- t.test(m3[inds2], m3[-inds2])\nt_w2_l <- t.test(l3[inds2], l3[-inds2])\n\nt_w3_m <- t.test(m3[inds3], m3[-inds3])\nt_w3_l <- t.test(l3[inds3], l3[-inds3])\n\nt_w4_m <- t.test(m3[inds4], m3[-inds4])\nt_w4_l <- t.test(l3[inds4], l3[-inds4])\n\nt_w5_m <- t.test(m3[inds5], m3[-inds5])\nt_w5_l <- t.test(l3[inds5], l3[-inds5])\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_df <- data.frame(\n  \"D\" = c(100, 300, 600, D, D, D, D, D),\n  \"W\" = c(W, W, W, 0.2 * W, 0.2 * W, 0.2 * W, 0.2 * W, 0.2 * W),\n  \"Mass\" = c(\n    t_d1_m_1$p.value,\n    t_d1_m_2$p.value,\n    t_d1_m_3$p.value,\n    t_w1_m$p.value,\n    t_w2_m$p.value,\n    t_w3_m$p.value,\n    t_w4_m$p.value,\n    t_w5_m$p.value\n  ),\n  \"Complete_log_likelihood\" = c(\n    t_d1_l_1$p.value,\n    t_d1_l_2$p.value,\n    t_d1_l_3$p.value,\n    t_w1_l$p.value,\n    t_w2_l$p.value,\n    t_w3_l$p.value,\n    t_w4_l$p.value,\n    t_w5_l$p.value\n  )\n)\n\n# test_df$Mass <- round(test_df$Mass, 4)\n# test_df$Complete_log_likelihood <- round(test_df$Complete_log_likelihood, 4)\n```\n:::\n\n\nNow the p values for the mass parameter and complete log-likelihood t-tests are shown in the below table.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nknitr::kable(test_df, caption = \"Convergence tests for consensus clustering\", digits = 3)\n```\n\n::: {.cell-output-display}\nTable: Convergence tests for consensus clustering\n\n|    D|   W|  Mass| Complete_log_likelihood|\n|----:|---:|-----:|-----------------------:|\n|  100| 500| 0.000|                   0.508|\n|  300| 500| 0.000|                   0.810|\n|  600| 500| 0.651|                   0.931|\n| 1000| 100| 0.630|                   0.446|\n| 1000| 100| 0.137|                   0.395|\n| 1000| 100| 0.485|                   0.627|\n| 1000| 100| 0.328|                   0.466|\n| 1000| 100| 0.217|                   0.067|\n:::\n:::\n\n\nThe mass is sampled via Metropolis Hastings, so it taking longer to converge than the complete log-likelihood (which is a direct function of the clustering) is not shocking.\n\n## Mean abolute difference between consensus matrices\n\nIn the paper I recommended using the below kind of plots, but these need more models for assessing as with only three levels of both the iteration and number of chains used we only have two data points for comparisons, so they have some limitations.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean_abs_diff_df <- makeCMComparisonSummaryDF(cms, models)\n\nmean_abs_diff_df |>\n  dplyr::filter(Quantity_varied == \"Depth\") |>\n  ggplot(aes(x = Depth, y = Mean_absolute_difference, color = factor(Width))) +\n  geom_line() +\n  labs(title = \"Assessing stability across cms for increasing chain depth\") +\n  ggthemes::scale_color_colorblind()\n```\n\n::: {.cell-output-display}\n![](consensus_clustering_files/figure-html/mean_abs_diff-1.png){width=672}\n:::\n\n```{.r .cell-code}\nmean_abs_diff_df |>\n  dplyr::filter(Quantity_varied == \"Width\") |>\n  ggplot(aes(x = Width, y = Mean_absolute_difference, color = factor(Depth))) +\n  geom_line() +\n  labs(title = \"Assessing stability across cms for increasing numbers of chains\") +\n  ggthemes::scale_color_colorblind()\n```\n\n::: {.cell-output-display}\n![](consensus_clustering_files/figure-html/mean_abs_diff-2.png){width=672}\n:::\n:::\n\n\n\n## Bayesian\n\nI am interested in how well the consensus clustering approximates the ergodic chain. Let's investiage this in a dataset where mixing will not be an issue. We'll run a number of chains on a two-dimensional dataset with well separate clusters and compare this to a consensus clustering of the same dataset. In both the short and long chains we will use longer chains than we need.\n\nCOmpare to 2D\n\n\n::: {.cell hash='consensus_clustering_cache/html/2d_6bed1ecfb2a09b9ee1d7e85e5a5fbf3c'}\n\n```{.r .cell-code}\nN_2d <- 200\nP_2d <- 2\n\ndata_2d <- MDIr::generateGaussianDataset(cluster_means = c(-2, 2), \n  std_dev = c(1, 1), \n  n = N_2d, \n  p = P_2d, \n  pi = c(0.5, 0.5)\n)\n\nD <- 500\nW <- 1000\n\nalloc_mat <- matrix(0, nrow = W, ncol = N_2d)\n\nfor(w in seq(1, W)) {\n  .mcmc <- callMixtureModel(data_2d$data, D, thin = D, type = \"G\", K = 50)\n  alloc_mat[w, ] <- .mcmc$allocations[2 , ]\n}\n\ncm <- createSimilarityMat(alloc_mat)\n\nn_chains <- 7\nR <- 2.5e4\nthin <- 25\nburn <- 1e4\n\npsms <- list()\n\nfor(ii in seq(1, n_chains)) {\n  .mcmc <- callMixtureModel(data_2d$data, R, thin, type = \"G\", K = 50)\n  psms[[ii]] <- createSimilarityMat(.mcmc$allocations[-seq(1, burn / thin), ])\n}\n\npsms[[n_chains + 1]] <- cm\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npsm_df <- prepSimilarityMatricesForGGplot(psms)\n\ntop_matrices <- psm_df |> \n  filter(Chain %in% c(n_chains, n_chains + 1)) |> \n    mutate(Type = case_when(\n      Chain == n_chains ~ paste(\"Chain\", n_chains),\n      Chain == n_chains + 1 ~ paste0(\"CC(\", D, \", \", W, \")\" )\n    )\n  )\n\nbottom_matrices <- psm_df |> \n  filter(Chain %in% seq(1, n_chains - 1)) |> \n  mutate(Type = paste0(\"Chain \", Chain))\n\np1 <- top_matrices |>\n  ggplot(aes(x = x, y = y, fill = Entry)) +\n  geom_tile() +\n  facet_wrap(~Type) +\n  scale_fill_gradient(low = \"#FFFFFF\", high = \"#146EB4\") +\n  labs(x = \"Item\", y = \"Item\", fill = \"Coclustering\\nproportion\") +\n  theme(\n    axis.text = element_blank(),\n    axis.ticks = element_blank(),\n    panel.grid = element_blank(),\n    axis.title.y = element_text(size = 10.5),\n    axis.title.x = element_text(size = 10.5),\n    plot.title = element_text(size = 18, face = \"bold\"),\n    plot.subtitle = element_text(size = 14),\n    strip.text.x = element_text(size = 10.5),\n    legend.text = element_text(size = 10.5)\n  )\n\np2 <- bottom_matrices |>\n  ggplot(aes(x = x, y = y, fill = Entry)) +\n  geom_tile() +\n  facet_wrap(~Type, nrow = 2) +\n  scale_fill_gradient(low = \"#FFFFFF\", high = \"#146EB4\") +\n  labs(x = \"Item\", y = \"Item\", fill = \"Coclustering\\nproportion\") +\n  theme(\n    axis.text = element_blank(),\n    axis.ticks = element_blank(),\n    panel.grid = element_blank(),\n    axis.title.y = element_text(size = 10.5),\n    axis.title.x = element_text(size = 10.5),\n    plot.title = element_text(size = 18, face = \"bold\"),\n    plot.subtitle = element_text(size = 14),\n    strip.text.x = element_text(size = 10.5),\n    legend.text = element_text(size = 10.5)\n  )\n  \np1 / p2 +\n  plot_layout(guides = \"collect\")\n```\n\n::: {.cell-output-display}\n![](consensus_clustering_files/figure-html/2dviz-1.png){width=672}\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}